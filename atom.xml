<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leafsu&#39;s Blogs</title>
  
  <subtitle>Good Good Study, Day Day up.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/leafsu3340.github.io/"/>
  <updated>2020-02-05T06:34:09.303Z</updated>
  <id>https://github.com/leafsu3340.github.io/</id>
  
  <author>
    <name>Leafsu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js上传文件的几种方式</title>
    <link href="https://github.com/leafsu3340.github.io/2020/02/05/js%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/leafsu3340.github.io/2020/02/05/js上传文件的几种方式/</id>
    <published>2020-02-05T06:31:12.183Z</published>
    <updated>2020-02-05T06:34:09.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-form表单文件上传"><a href="#1-form表单文件上传" class="headerlink" title="1.form表单文件上传"></a>1.form表单文件上传</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://localhost:8081/images&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li>图片上传的请求方式必须为post</li><li>enctype=”multipart/form-data” 参数不能少<blockquote><p>enctype=”multipart/form- data”：采用multipart格式上传文件，此时request头会显示 Content-Type:multipart/form-data; boundary=—-WebKitFormBoundaryzr34cwJ67R95KQC9</p></blockquote></li></ul><h1 id="2-借助form的ajax文件上传"><a href="#2-借助form的ajax文件上传" class="headerlink" title="2.借助form的ajax文件上传"></a>2.借助form的ajax文件上传</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;uploadForm&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;Upload&quot; id=&quot;upload&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        $(&apos;#upload&apos;).click(function() &#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: &quot;http://localhost:8081/images&quot;,</span><br><span class="line">                type: &quot;post&quot;,</span><br><span class="line">                data: new FormData($(&apos;#uploadForm&apos;)[0]),</span><br><span class="line">                cache: false,</span><br><span class="line">                processData:false,</span><br><span class="line">                contentType:false,</span><br><span class="line">                success: function(res) &#123;</span><br><span class="line">                    console.log(res)</span><br><span class="line">                &#125;,</span><br><span class="line">                error: function(err) &#123;</span><br><span class="line">                    console.log(err)    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>processData设置为false。因为data值是FormData对象，不需要对数据做处理。<blockquote><p>processData: false // 不要对data参数进行序列化处理，默认为true</p></blockquote></li><li><form>标签添加enctype="multipart/form-data"属性。</form></li><li>cache设置为false，上传文件不需要缓存。</li><li>contentType设置为false。因为是由<form>表单构造的FormData对象，且已经声明了属性enctype=”multipart/form-data”，所以这里设置为false。</form></li></ul><h1 id="3-不借助form的ajax文件上传"><a href="#3-不借助form的ajax文件上传" class="headerlink" title="3.不借助form的ajax文件上传"></a>3.不借助form的ajax文件上传</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Upload&quot; id=&quot;upload&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $(function () &#123;</span><br><span class="line">      $(&apos;#upload&apos;).click(function() &#123;</span><br><span class="line">            let file = $(&quot;#file&quot;)[0].files[0];</span><br><span class="line">            //创建formdata对象</span><br><span class="line">            let formData = new FormData();</span><br><span class="line">            formData.append(&quot;file&quot;,file);</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: &quot;http://localhost:8081/images&quot;,</span><br><span class="line">                type: &quot;post&quot;,</span><br><span class="line">                data: formData,</span><br><span class="line">                cache: false,</span><br><span class="line">                processData:false,</span><br><span class="line">                contentType:false,</span><br><span class="line">                // headers: &#123; &apos;Content-Type&apos;: &apos;multipart/form-data&apos; &#125;,</span><br><span class="line">                success: function(res) &#123;</span><br><span class="line">                    console.log(res)</span><br><span class="line">                &#125;,</span><br><span class="line">                error: function(err) &#123;</span><br><span class="line">                    console.log(err)    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>append()的第二个参数应是文件对象，即$(‘#file’)[0].files[0]。</li><li>contentType也要设置为‘false’。</li><li>从代码$(‘#file’)[0].files[0]中可以看到一个&lt;input type=”file”&gt;标签能够上传多个文件， 只需要在&lt;input type=”file”&gt;里添加multiple或multiple=”multiple”属性。</li></ul><h1 id="4-flash上传"><a href="#4-flash上传" class="headerlink" title="4.flash上传"></a>4.flash上传</h1><p>很多时候上传的需求要求显示上传进度、中断上传过程、大文件分片上传等等，这时传统的表单上传很难实现这些功能，于是产生了使用Flash上传的方式，它采用Flash作为一个中间代理层，代替客户端跟服务端通信，此外，它也对客户端的文件选择方面拥有更多的控制权，比input[type=”file”] 要大得多。</p><p>在这里我使用了jQuery封装好的uploadify插件来进行演示，一般这类插件都自带了上传用的Flash文件，因为跟服务端回传的数据和展示跟客户端的交互，都是Flash文件的接口跟插件来对接的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;file_upload&quot;&gt;&lt;/div&gt;</span><br><span class="line">// html部分很简单，预留一个hook后，插件会在这个节点内部创建Flash的object，</span><br><span class="line">// 并且还附带创建了上传进度、取消控件和多文件队列展示等界面。</span><br><span class="line"></span><br><span class="line">$(function() &#123;</span><br><span class="line">  $(&quot;#file_upload&quot;).uploadify(&#123;</span><br><span class="line">      auto: true,</span><br><span class="line">      method: &quot;Post&quot;,</span><br><span class="line">      width: 120,</span><br><span class="line">      height: 30,</span><br><span class="line">      swf: &apos;./uploadify.swf&apos;,</span><br><span class="line">      uploader: &apos;http://uploadUrl&apos;,</span><br><span class="line">      formData: &#123;</span><br><span class="line">          token: $(&quot;#token&quot;).val()</span><br><span class="line">      &#125;,</span><br><span class="line">      fileObjName: &quot;file&quot;,</span><br><span class="line">      onUploadSuccess: function(file, data, response)&#123;</span><br><span class="line">          // 根据返回结果指定界面操作</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于jQuery.uploadify可以访问了解： <a href="https://note.youdao.com/" target="_blank" rel="noopener">http://www.uploadify.com/documentation/</a> 。值得注意的是flash并不适合手机端应用，更好的解决方案是使用flash+html5来解决平台的兼容性问题。</p><h1 id="5-截图粘贴上传"><a href="#5-截图粘贴上传" class="headerlink" title="5.截图粘贴上传"></a>5.截图粘贴上传</h1><p>截图粘贴上传的核心思想是，监听粘贴事件，然后获取剪切板中的数据，如果是一张图片，则触发上传事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;textarea&quot;).on(&quot;paste&quot;, function(e)&#123;</span><br><span class="line">   e.stopPropagation();</span><br><span class="line">   var self = this;</span><br><span class="line">   var clipboardData = e.originalEvent.clipboardData;</span><br><span class="line">   if (clipboardData.items.length &lt;= 0) &#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   var file = clipboardData.items[0].getAsFile();</span><br><span class="line">   if (!file) &#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   var formData = new FormData();</span><br><span class="line">   formData.append(&quot;file&quot;, file);</span><br><span class="line">   formData.append(&quot;token&quot;, $(&quot;#token&quot;).val());</span><br><span class="line">   $.ajax(&#123;</span><br><span class="line">       url: &quot;http://uploadUrl&quot;,</span><br><span class="line">       type: &quot;POST&quot;,</span><br><span class="line">       data: formData,</span><br><span class="line">   &#125;).done(function(response) &#123;</span><br><span class="line">       // 根据返回结果指定界面操作</span><br><span class="line">   &#125;);</span><br><span class="line">   e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，上传的过程都是一样的，主要是获取文件的方式。 当进行粘贴（右键paste/ctrl+v）操作时，触发剪贴板事件’paste’，从系统剪切板获取内容，而系统剪切板的数据在不同浏览器保存在不同的位置：</p><ul><li>IE内核：windows.clipboardData</li><li>其它：e.originalEvent.clipboardData</li></ul><h1 id="6-拖拽上传"><a href="#6-拖拽上传" class="headerlink" title="6.拖拽上传"></a>6.拖拽上传</h1><p>拖拽上传的方式，支持的浏览器比较少，因为它用到了HTML5的两个新的属性（API）一个是Drag and Drop,一个是File API。</p><p>上传域监听拖拽的三个事件：dragEnter、dragOver和drop，分别对应拖拽至、拖拽时和释放三个操作的处理机制，当然你也可以监听dragLeave事件。<br>HTML5的File API提供了一个FileList的接口，它可以通过拖拽事件的e.dataTransfer.files来传递的文件信息，获取本地文件列表信息。</p><p>File API在HTML5规范中只是草案，在 W3C 草案中，File 对象只包含文件名、文件类型和文件大小等只读属性。但部分浏览器在草案之外提供了一个名为 FileReader 的对象，用以读取文件内容，并且可以监控读取状态，它提供的方法有： “readAsBinaryString” ，”readAsDataURL” ，”readAsText” ，”abort” 等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// dragenter</span><br><span class="line">$(&quot;#textarea&quot;).on(&quot;dragenter&quot;, function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;);</span><br><span class="line">// dragover</span><br><span class="line">$(&quot;#textarea&quot;).on(&quot;dragover&quot;, function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;);</span><br><span class="line">// drop</span><br><span class="line">$(&quot;#textarea&quot;).on(&quot;drop&quot;, function(e)&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault(); // 禁用页面的默认拖拽功能：图片拖进来的时候会默认被浏览器打开</span><br><span class="line">    var files = e.originalEvent.dataTransfer.files;</span><br><span class="line">    _.each(files, function(file) &#123;</span><br><span class="line">        if (!/^image*/.test(file.type)) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        var fileReader = new FileReader();</span><br><span class="line">        fileReader.onload = function() &#123;</span><br><span class="line">          //uploadFile(file);</span><br><span class="line">        &#125;;</span><br><span class="line">        fileReader.readAsDataURL(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>拖拽上传过程中的几个关键点：</p><p>在drop事件触发后通过e.dataTransfer.files获取拖拽文件列表，在jQuery中是e.originalEvent.dataTransfer.files<br>拖拽上传仅支持图片，文件对象中file.type标识了文件类型。<br>由于可能是多图拖拽，所以可以遍历图片上传，这里用了Underscore的each方法。</p><blockquote><p>这里用readAsDataURL读取文件内容为二进制文件，==你还可以将其转换为Base64方式上传，只是http协议里面存在对非二进制数据的上传大小限制为2M。==</p></blockquote><p>上传的过程跟前面的方式相同，即：创建FormData对象并发起Ajax请求。</p><h1 id="7-webuploader"><a href="#7-webuploader" class="headerlink" title="7.webuploader"></a>7.webuploader</h1><p><a href="https://note.youdao.com/" target="_blank" rel="noopener">https://fex.baidu.com/webuploader/getting-started.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-form表单文件上传&quot;&gt;&lt;a href=&quot;#1-form表单文件上传&quot; class=&quot;headerlink&quot; title=&quot;1.form表单文件上传&quot;&gt;&lt;/a&gt;1.form表单文件上传&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="前端开发" scheme="https://github.com/leafsu3340.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="https://github.com/leafsu3340.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>魔鬼经济学</title>
    <link href="https://github.com/leafsu3340.github.io/2020/02/05/%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    <id>https://github.com/leafsu3340.github.io/2020/02/05/魔鬼经济学/</id>
    <published>2020-02-05T06:26:58.000Z</published>
    <updated>2020-02-05T06:28:11.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>表象与真实世界的差距。</p></blockquote><ul><li>人性动机的复杂性。做事考虑人性的动机，物质（金钱）、道德、社会的影响。人的天性是喜欢作弊，以达到利益最大化（作弊不劳而获是人类最原始的经济活动）。尝试从一个作弊者的角度思考问题。</li></ul><blockquote><p>道德代表着这个世界在我们心中应该如何运转；经济学代表着这个世界真实的运转方式。</p></blockquote><blockquote><p>值得拥有的东西就是值得为之欺骗、作弊的东西。</p></blockquote><ul><li>信息的复杂性（不对称性）；各行各业的人都在利用信息的不对称性谋取利益。强者利用信息的不对称性树立威信、获取利益、形成阶层优势；弱者要敏锐的洞察，懂得规避信息不对称的陷阱，而不被坑到。</li></ul><blockquote><p>获取更多的信息，形成优势，实现将为打击</p></blockquote><ul><li>直觉思维的陷阱。人的直觉是不可靠的，一切应该从数据分析的角度剖析问题。</li><li>堤防数据的隐秘性(相关关系，因果关系)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;表象与真实世界的差距。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;人性动机的复杂性。做事考虑人性的动机，物质（金钱）、道德、社会的影响。人的天性是喜欢作弊，以达到利益最大化（作弊不劳而获是人类最原始的经济活动）。尝试从一个作弊者的角度思
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://github.com/leafsu3340.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="booknote" scheme="https://github.com/leafsu3340.github.io/tags/booknote/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计(第3版)</title>
    <link href="https://github.com/leafsu3340.github.io/2020/02/05/Javascript-booknote/"/>
    <id>https://github.com/leafsu3340.github.io/2020/02/05/Javascript-booknote/</id>
    <published>2020-02-05T06:07:56.239Z</published>
    <updated>2020-02-05T06:16:10.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《JavaScript高级程序设计(第3版) (图灵程序设计丛书)》<br>作者：泽卡斯(Zakas. Nicholas C.)</p></blockquote><h2 id="第1章-BOM"><a href="#第1章-BOM" class="headerlink" title="第1章  BOM"></a>第1章  BOM</h2><ul><li>window对象  核心/Global对象</li><li>location对象</li><li>navigator对象<h2 id="第2章-在HTML中使用JavaScript"><a href="#第2章-在HTML中使用JavaScript" class="headerlink" title="第2章　在HTML中使用JavaScript"></a>第2章　在HTML中使用JavaScript</h2></li><li>2.5　小结 &gt; 位置 784<br>使用 defer 属性 可以 让 脚本 在 文档 完全 呈现 之后 再 执行。 延迟 脚本 总是 按照 指定 它们 的 顺序 执行。</li><li>2.5　小结 &gt; 位置 785<br>使用 async 属性 可以 表示 当前 脚本 不必 等待 其他 脚本， 也不 必 阻塞 文档 呈现。 不能 保证 异步 脚本 按照 它们 在 页面 中 出现 的 顺序 执行。<h2 id="第4章-变量、作用域和内存问题"><a href="#第4章-变量、作用域和内存问题" class="headerlink" title="第4章　变量、作用域和内存问题"></a>第4章　变量、作用域和内存问题</h2></li><li>4.4　小结 &gt; 位置 3005<br>“标记 清除” 是 目前 主流 的 垃圾 收集 算法， 这种 算法 的 思想 是给 当前 不使 用的 值 加上 标记， 然后 再回 收 其 内存。</li><li>4.4　小结 &gt; 位置 3007<br>另一种 垃圾 收集 算法 是“ 引用 计数”， 这种 算法 的 思想 是 跟踪 记录 所有 值 被 引用 的 次数。 JavaScript 引擎 目前 都不 再 使用 这种 算法； 但在 IE 中 访问 非 原生 JavaScript 对象（ 如 DOM 元素） 时， 这种 算法 仍然 可能 会 导致 问题。<h2 id="第8章-BOM"><a href="#第8章-BOM" class="headerlink" title="第8章　BOM"></a>第8章　BOM</h2></li><li>8.1　window对象 &gt; 位置 6833<br>BOM 的 核心 对象 是 window， 它 表示 浏览器 的 一个 实例。</li><li>8.1　window对象 &gt; 位置 6882<br>如果 页面 中 包含 框架， 则 每个 框架 都 拥有 自己的 window 对象， 并且 保存 在 frames 集合 中。</li><li>8.3　navigator对象 &gt; 位置 7430<br>最早 由 Netscape Navigator 2. 0 引入 的 navigator 对象， 现在 已经 成为 识别 客户 端 浏览器 的 事实 标准。</li><li>8.3　navigator对象 &gt; 位置 7539<br>检测 浏览器 中 是否 安装 了 特定 的 插件 是 一种 最 常见 的 检测 例程。 对于 非 IE 浏览器， 可以 使用 plugins 数组 来 达到 这个 目的。</li><li>8.3　navigator对象 &gt; 位置 7569<br>检测 IE 中的 插件 比较 麻烦， 因为 IE 不支持 Netscape 式 的 插件。 在 IE 中 检测 插件 的 唯一 方式 就是 使用 专有 的 ActiveXObject 类型， 并 尝试 创建 一个 特定 插件 的 实例。 IE 是以 COM 对象 的 方式 实现 插件 的， 而 COM 对象 使用 唯一 标识符 来 标识。</li><li>8.3　navigator对象 &gt; 位置 7607<br>Firefox 2 为 navigator 对象 新增 了 registerContentHandler() 和 registerProtocolHandler() 方法（ 这 两个 方法 是在 HTML5 中 定义 的， 相关 内容 将 在 第 22 章 讨论）。 这 两个 方法 可以 让 一个 站点 指明 它可 以 处理 特定 类型 的 信息。</li><li>8.6　小结 &gt; 位置 7741<br>浏览器 对象 模型（ BOM） 以 window 对象 为 依托， 表示 浏览器 窗口 以及 页面 可见 区域。</li><li>8.6　小结 &gt; 位置 7745<br>在使 用 框架 时， 每个 框架 都有 自己的 window 对象 以及 所有 原生 构造 函数 及其他 函数 的 副本。</li><li>8.6　小结 &gt; 位置 7749<br>top 对象 始终 指向 最 外围 的 框架， 也就是 整个 浏览器 窗口。</li><li>8.6　小结 &gt; 位置 7751<br>parent 对象 表示 包含 当前 框架 的 框架， 而 self 对象 则 回 指 window。</li><li>8.6　小结 &gt; 位置 7761<br>screen 对象 中 保存 着 与 客户 端 显示器 有关 的 信息，</li><li>8.6　小结 &gt; 位置 7763<br>history 对象 为 访问 浏览器 的 历史 记录<h2 id="第9章-客户端检测"><a href="#第9章-客户端检测" class="headerlink" title="第9章　客户端检测"></a>第9章　客户端检测</h2></li><li>9.1　能力检测 &gt; 位置 7775<br>最 常用 也 最为 人们 广泛 接受 的 客户 端 检测 形式 是 能力 检测（ 又称 特性 检测）。</li><li>9.2　怪癖检测 &gt; 位置 7879<br>与 能力 检测 类似， 怪癖 检测（ quirks detection） 的 目标 是 识别 浏览器 的 特殊 行为。</li><li>9.2　怪癖检测 &gt; 位置 7880<br>不同， 怪癖 检测 是 想要 知道 浏览器 存在 什么 缺陷（“ 怪癖” 也就是 bug）。 这</li><li>9.3　用户代理检测 &gt; 位置 7905<br>在 每一 次 HTTP 请求 过程中， 用户 代理 字符串 是 作为 响应 首部 发送 的， 而且 该 字符串 可以 通过 JavaScript 的 navigator. userAgent 属性 访问。</li><li>9.3　用户代理检测 &gt; 位置 7907<br>访问。 在 服务器 端， 通过 检测 用户 代理 字符串 来 确定 用户 使用 的 浏览器 是一 种 常用 而且 广为 接受 的 做法。 而在 客户 端， 用户 代理 检测 一般 被 当作 一种 万不得已 才 用的 做法， 其 优先级 排在 能力 检测 和（ 或） 怪癖 检测 之后。</li><li>9.3　用户代理检测 &gt; 位置 7912<br>HTTP 规范（ 包括 1. 0 和 1. 1 版） 明确 规定， 浏览器 应该 发送 简短 的 用户 代理 字符串， 指明 浏览器 的 名称 和 版 本号。</li><li>9.3　用户代理检测 &gt; 位置 7986<br>Gecko 是 Firefox 的 呈现 引擎。</li><li>9.3　用户代理检测 &gt; 位置 8033<br>Safari 的 呈现 引擎 叫 WebKit，</li><li>9.3　用户代理检测 &gt; 位置 8065<br>谷 歌 公司 的 Chrome 浏览器 以 WebKit 作为 呈现 引擎， 但 使用 了 不同 的 JavaScript 引擎。</li><li>9.3　用户代理检测 &gt; 位置 8110<br>移动 操作系统 iOS 和 Android 默认 的 浏览器 都 基于 WebKit， 而且 都 像 它们 的 桌面 版 一样， 共享 相同 的 基本 用户 代理 字符串 格式。</li><li>9.3　用户代理检测 &gt; 位置 8127<br>用户 代理 字符串 来 检测 特定 的 浏览器 并不是 一件 轻松 的 事。</li><li>9.3　用户代理检测 &gt; 位置 8136<br>确切 知道 浏览器 的 名字 和 版本 号 不如 确切 知道 它 使用 的 是什么 呈现 引擎。</li><li>9.3　用户代理检测 &gt; 位置 8139<br>要 编写 的 脚本 将 主要 检测 五大 呈现 引擎： IE、 Gecko、 WebKit、 KHTML 和 Opera。</li><li>9.3　用户代理检测 &gt; 位置 8648<br>用户 代理 检测 是 客户 端 检测 的 最后 一个 选择。 只要 可能， 都应 该 优先 采用 能力 检测 和 怪癖 检测。</li><li>9.4　小结 &gt; 位置 8667<br>在 决定 使用 哪种 客户 端 检测 方法 时， 一般应 优先 考虑 使用 能力 检测。 怪癖 检测 是 确定 应该 如何 处理 代码 的 第二 选择。 而用 户 代理 检测 则是 客户 端 检测 的 最后 一种 方案， 因为 这种 方法 对 用户 代理 字符串 具有 很强 的 依赖性。<h2 id="第10章-DOM"><a href="#第10章-DOM" class="headerlink" title="第10章　DOM"></a>第10章　DOM</h2></li><li>位置 8676<br>IE 中的 所有 DOM 对象 都是 以 COM 对象 的 形式 实现 的。</li><li>10.1　节点层次 &gt; 位置 8693<br>DOM1 级 定义 了 一个 Node 接口， 该 接口 将由 DOM 中的 所有 节点 类型 实现。</li><li>10.1　节点层次 &gt; 位置 8697<br>类型。 JavaScript 中的 所有 节点 类型 都 继承 自 Node 类型， 因此 所有 节点 类型 都 共享 着 相同 的 基本 属性 和 方法。</li><li>10.1　节点层次 &gt; 位置 8698<br>每个 节点 都有 一个 nodeType 属性， 用于 表明 节点 的 类型。 节点 类型 由 在 Node 类型 中 定义 的 下列 12 个数 值 常量 来 表示， 任何 节点 类型 必 居 其一：</li><li>10.1　节点层次 &gt; 位置 8720<br>为了 确保 跨 浏览器 兼容， 最好 还 是将 nodeType 属性 与 数字 值 进行 比较，</li><li>10.1　节点层次 &gt; 位置 8722<br>if (someNode. nodeType == 1){ //适用于 所有 浏览器 alert(“ Node is an element.”); }</li><li>10.1　节点层次 &gt; 位置 8744<br>每个 节点 都有 一个 childNodes 属性， 其中 保存 着 一个 NodeList 对象。</li><li>10.1　节点层次 &gt; 位置 8746<br>NodeList 是一 种类 数组 对象， 用于 保存 一组 有序 的 节点， 可以 通过 位置 来访 问这 些 节点。 请注意， 虽然 可以 通过 方 括号 语法 来 访问 NodeList 的 值， 而且 这个 对象 也有 length 属性， 但它 并不是 Array 的 实例。</li><li>10.1　节点层次 &gt; 位置 8765<br>//在 IE8 及之 前 版本 中 无效 var arrayOfNodes = Array. prototype. slice. call( someNode. childNodes, 0);</li><li>10.1　节点层次 &gt; 位置 8767<br>IE8 及 更早 版本 将 NodeList 实现 为 一个 COM 对象，</li><li>10.1　节点层次 &gt; 位置 8769<br>要想 在 IE 中将 NodeList 转换 为 数组， 必须 手动 枚举 所有 成员。</li><li>10.1　节点层次 &gt; 位置 8778<br>每个 节点 都有 一个 parentNode 属性，</li><li>10.1　节点层次 &gt; 位置 8783<br>节点。 通过 使用 列表 中 每个 节点 的 previousSibling 和 nextSibling 属性， 可以 访问 同一 列表 中的 其他 节点。 列表</li><li>10.1　节点层次 &gt; 位置 8794<br>父 节点 与其 第一个 和 最后 一个 子 节点 之间 也 存在 特殊 关系。 父 节点 的 firstChild 和 lastChild 属性 分别 指向 其 childNodes 列表 中的 第一个 和 最后 一个 节点。</li><li>10.1　节点层次 &gt; 位置 8813<br>所有 节点 都有 的 最后 一个 属性 是 ownerDocument， 该 属性 指向 表示 整个 文档 的 文档 节点。</li><li>10.1　节点层次 &gt; 位置 8846<br>appendChild() 和 insertBefore() 方法 都 只 插入 节点， 不会 移 除 节点。</li><li>10.1　节点层次 &gt; 位置 8852<br>使用 replaceChild() 插入 一个 节点 时， 该 节点 的 所有 关系 指针 都会 从 被 它 替换 的 节点 复制 过来。</li><li>10.1　节点层次 &gt; 位置 8853<br>过来。 尽管 从技术上 讲， 被 替换 的 节点 仍然 还在 文档 中， 但它 在 文档 中 已经 没有 了 自己的 位置。</li><li>10.1　节点层次 &gt; 位置 8854<br>只想 移 除 而非 替换 节点， 可以 使用 removeChild() 方法。</li><li>10.1　节点层次 &gt; 位置 8859<br>与 使用 replaceChild() 方法 一样， 通过 removeChild() 移 除 的 节点 仍然 为 文档 所有， 只不过 在 文档 中 已经 没有 了 自己的 位置。</li><li>10.1　节点层次 &gt; 位置 8911<br>其 子 节点 可能 是 一个 DocumentType（ 最多 一个）、 Element（ 最多 一个）、 ProcessingInstruction 或 Comment。</li><li>10.1　节点层次 &gt; 位置 9002<br>接下来 要 介绍 的 3 个 属性 都与 对 网页 的 请求 有关， 它们 是 URL、 domain 和 referrer。</li><li>10.1　节点层次 &gt; 位置 9005<br>URL 属性 中 包含 页面 完整 的 URL（ 即地 址 栏中 显示 的 URL）， domain 属性 中 只 包含 页面 的 域名， 而 referrer 属性 中 则 保存 着 链接 到 当前 页面 的 那个 页面 的 URL。</li><li>10.2　DOM操作技术 &gt; 位置 10216<br>理解 NodeList 及其“ 近亲” NamedNodeMap 和 HTMLCollection， 是 从 整体 上 透彻 理解 DOM 的 关键 所在。</li><li>10.2　DOM操作技术 &gt; 位置 10235<br>如果 想要 迭代 一个 NodeList， 最好 是 使用 length 属性 初始化 第二个 变量， 然后 将 迭代 器 与 该 变量 进行 比较，</li><li>10.3　小结 &gt; 位置 10251<br>最 基本 的 节点 类型 是 Node， 用于 抽象 地表 示 文档 中 一个 独立 的 部分； 所有 其他 类型 都 继承 自 Node。<h2 id="第11章-DOM扩展"><a href="#第11章-DOM扩展" class="headerlink" title="第11章　DOM扩展"></a>第11章　DOM扩展</h2></li><li>11.3　HTML5 &gt; 位置 10505<br>charset 属性 表示 文档 中 实际 使用 的 字符 集， 也可以 用来 指定 新 字符 集。 默认 情况下， 这个 属 性的 值 为” UTF- 16”， 但可以 通过&lt; meta&gt; 元素、 响应 头部 或 直接 设置 charset 属性 修改 这个 值。</li><li>11.3　HTML5 &gt; 位置 10681<br>在 使用 innerHTML、 outerHTML 属性 和 insertAdjacentHTML() 方法 时， 最好 先手 工 删除 要被 替换 的 元素 的 所有 事件 处理 程序 和 JavaScript 对象 属性（</li><li>11.3　HTML5 &gt; 位置 10712<br>//让 元素 可见 document. forms[ 0]. scrollIntoView();</li><li>11.4　专有扩展 &gt; 位置 10730<br>要 强制 浏览器 以 某种 模式 渲染 页面， 可以 使用 HTTP 头部 信息 X- UA- Compatible， 或 通过 等价 的&lt; meta&gt; 标签 来 设置：</li><li>11.4　专有扩展 &gt; 位置 10910<br>scrollIntoViewIfNeeded( alignCenter)： 只在 当前 元素 在 视 口中 不 可见 的 情况下， 才 滚动 浏览器 窗口 或 容器 元素， 最终 让 它可 见。</li><li>11.4　专有扩展 &gt; 位置 10914<br>scrollByLines( lineCount)： 将 元素 的 内容 滚动 指 定的 行 高， lineCount 值 可以 是 正值， 也可以 是 负值。</li><li>11.4　专有扩展 &gt; 位置 10917<br>scrollByPages( pageCount)： 将 元素 的 内容 滚动 指定 的 页面 高度， 具体 高度 由 元素 的 高度 决定。</li><li>11.4　专有扩展 &gt; 位置 10919<br>是， scrollIntoView() 和 scrollIntoViewIfNeeded() 的 作用 对象 是 元素 的 容器， 而 scrollByLines() 和 scrollByPages() 影响 的 则是 元素 自身。</li><li>11.5　小结 &gt; 位置 10932<br>Element Traversal， 为 DOM 元素 定义 了 额外 的 属性， 让开 发 人员 能够 更 方便 地 从 一个 元素 跳到 另一个 元素。 之所以 会 出现 这个 扩展， 是因为 浏览器 处理 DOM 元素 间 空白 符 的 方式 不一样。<h2 id="第12章-DOM2和DOM3"><a href="#第12章-DOM2和DOM3" class="headerlink" title="第12章　DOM2和DOM3"></a>第12章　DOM2和DOM3</h2></li><li>位置 10940<br>DOM1 级 主要 定义 的 是 HTML 和 XML 文档 的 底层 结构。 DOM2 和 DOM3 级 则在 这个 结构 的 基础上 引入 了 更多 的 交互 能力， 也 支持 了 更 高级的 XML 特性。</li><li>12.1　DOM变化 &gt; 位置 10951<br>DOM2 级 和 3 级 的 目的在于 扩展 DOM API， 以 满足 操作 XML 的 所有 需求， 同时 提供 更好 的 错误 处理 及 特性 检测 能力。 从 某种 意义上 讲， 实现 这一 目的 很大 程度 意味着 对 命名 空间 的 支持。“ DOM2 级 核心” 没有 引入 新 类型， 它 只是 在 DOM1 级 的 基础上 通过 增加 新方法 和 新 属性 来 增强 了 既有 类型。“ DOM3 级 核心” 同样 增强 了 既有 类型， 但也 引入 了 一些 新 类型。</li><li>12.2　样式 &gt; 位置 11613<br>offsetHeight： 元素 在 垂直 方向 上 占用 的 空间 大小， 以 像素 计。 包括 元素 的 高度、（ 可见 的） 水平 滚动 条 的 高度、 上边 框 高度 和 下边 框 高度。</li><li>12.2　样式 &gt; 位置 11615<br>offsetWidth： 元素 在 水平 方向 上 占用 的 空间 大小， 以 像素 计。 包括 元素 的 宽度、（ 可见 的） 垂直 滚动 条 的 宽度、 左边 框 宽度 和 右边 框 宽度。</li><li>12.2　样式 &gt; 位置 11617<br>offsetLeft： 元素 的 左 外 边框 至 包含 元素 的 左 内 边框 之间 的 像素 距离。</li><li>12.2　样式 &gt; 位置 11618<br>offsetTop： 元素 的 上 外 边框 至 包含 元素 的 上 内 边框 之间 的 像素 距离。</li><li>12.2　样式 &gt; 位置 11619<br>其中， offsetLeft 和 offsetTop 属性 与 包含 元素 有关， 包含 元素 的 引用 保存 在 offsetParent 属性 中。</li><li>12.2　样式 &gt; 位置 11629<br>要想 知道 某个 元素 在 页 面上 的 偏移量， 将 这个 元素 的 offsetLeft 和 offsetTop 与其 offsetParent 的 相同 属性 相加， 如此 循环 直至 根 元素， 就可以 得到 一个 基本 准确 的 值。</li><li>12.2　样式 &gt; 位置 11657<br>其中， clientWidth 属性 是 元素 内容 区 宽度 加上 左右 内 边距 宽度；</li><li>12.2　样式 &gt; 位置 11658<br>clientHeight 属性 是 元素 内容 区 高度 加上 上下 内 边距 高度。</li><li>12.2　样式 &gt; 位置 11685<br>scrollHeight： 在 没有 滚动 条 的 情况下， 元素 内容 的 总 高度。</li><li>12.2　样式 &gt; 位置 11686<br>scrollWidth： 在 没有 滚动 条 的 情况下， 元素 内容 的 总 宽度。</li><li>12.2　样式 &gt; 位置 11688<br>scrollLeft： 被 隐藏 在内 容 区域 左侧 的 像 素数。 通过 设置 这个 属性 可以 改变 元素 的 滚动 位置。</li><li>12.2　样式 &gt; 位置 11689<br>scrollTop： 被 隐藏 在内 容 区域 上方 的 像 素数。 通过 设置 这个 属性 可以 改变 元素 的 滚动 位置。</li><li>12.2　样式 &gt; 位置 11733<br>IE、 Firefox 3+、 Safari 4+、 Opera 9. 5 及 Chrome 为 每个 元素 都 提供 了 一个 getBoundingClientRect() 方法。 这个 方法 返回 会 一个 矩形 对象， 包含 4 个 属性： left、 top、 right 和 bottom。 这些 属性 给出 了 元素 在 页面 中 相对于 视 口 的 位置。</li><li>12.2　样式 &gt; 位置 11758<br>信息。 一般来说， right 和 left 的 差值 与 offsetWidth 的 值 相等， 而 bottom 和 top 的 差值 与 offsetHeight 相等。</li><li>12.3　遍历 &gt; 位置 11788<br>“DOM2 级 遍历 和 范围” 模块 定义 了 两个 用于 辅助 完成 顺序 遍历 DOM 结构 的 类型： NodeIterator 和 TreeWalker。 这 两个 类型 能够 基于 给定 的 起点 对 DOM 结构 执行 深度 优先（ depth- first） 的 遍历 操作。</li><li>12.3　遍历 &gt; 位置 11821<br>NodeIterator 类型 是 两者 中 比较 简单 的 一个， 可以 使用 document. createNodeIterator() 方法 创建 它的 新 实例。</li><li>12.3　遍历 &gt; 位置 11880<br>NodeIterator 类型 的 两个 主要 方法 是 nextNode() 和 previousNode()。</li><li>12.3　遍历 &gt; 位置 11886<br>节点。 当 遍历 到 DOM 子 树 的 最后 一个 节点 时， nextNode() 返回 null。</li><li>12.3　遍历 &gt; 位置 11925<br>TreeWalker 是 NodeIterator 的 一个 更 高级的 版本。 除了 包括 nextNode() 和 previousNode() 在内 的 相同 的 功能 之外， 这个 类型 还 提供 了 下列 用于 在 不同 方向 上 遍历 DOM 结构 的 方法。</li><li>12.5　小结 &gt; 位置 12438<br>要 确定 某个 元素 的 计算 样式（ 包括 应用 给 它的 所有 CSS 规则）， 可以 使用 getComputedStyle() 方法。</li><li>12.5　小结 &gt; 位置 12440<br>IE 不支持 getComputedStyle() 方法， 但 为所 有 元素 都 提供 了 能够 返回 相同 信息 currentStyle 属性。</li><li>12.5　小结 &gt; 位置 12441<br>可以 通过 document. styleSheets 集合 访问 样式 表。</li><li>12.5　小结 &gt; 位置 12451<br>使用范围 选区 可以 在 删除 文档 中 某些 部分 的 同时， 保持 文档 结构 的 格式 良好， 或者 复制 文档 中的 相应 部分。<h2 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章　事件"></a>第13章　事件</h2></li><li>位置 12455<br>JavaScript 与 HTML 之间 的 交互 是 通过 事件 实现 的。</li><li>位置 12457<br>这种 在传 统 软件 工程 中 被称为 观察员 模式 的 模型， 支持 页面 的 行为（ JavaScript 代码） 与 页面 的 外观（ HTML 和 CSS 代码） 之间 的 松散 耦合。</li><li>13.1　事件流 &gt; 位置 12471<br>事件 流 描述 的 是 从 页面 中 接收 事件 的 顺序。</li><li>13.1　事件流 &gt; 位置 12513<br>“DOM2 级 事件” 规定 的 事件 流 包括 三个 阶段： 事件 捕获 阶段、 处于 目标 阶段 和 事件 冒泡 阶段。 首先</li><li>13.2　事件处理程序 &gt; 位置 12626<br>“DOM2 级 事件” 定义 了 两个 方法， 用于 处理 指定 和 删除 事件 处理 程序 的 操作： addEventListener() 和 removeEventListener()。</li><li>13.2　事件处理程序 &gt; 位置 12628<br>所有 DOM 节点 中 都 包含 这 两个 方法， 并且 它们 都 接受 3 个 参数： 要 处理 的 事件 名、 作为 事件 处理 程序 的 函数 和 一个 布尔 值。 最后 这个 布尔 值 参数 如果 是 true， 表示 在 捕获 阶段 调用 事件 处理 程序； 如果 是 false， 表示 在 冒泡 阶段 调用 事件 处理 程序。</li><li>13.2　事件处理程序 &gt; 位置 12654<br>传入 removeEventListener() 中的 事件 处理 程序 函数 必须 与 传入 addEventListener() 中的 相同，</li><li>13.2　事件处理程序 &gt; 位置 12666<br>IE 实现 了 与 DOM 中 类似 的 两个 方法： attachEvent() 和 detachEvent()。 这 两个 方法 接受 相同 的 两个 参数： 事件 处理 程序 名称 与 事件 处理 程序 函数。</li><li>13.5　内存和性能 &gt; 位置 14571<br>对“ 事件 处理 程序 过多” 问题 的 解决 方案 就是 事件 委托。</li><li>13.5　内存和性能 &gt; 位置 14620<br>每当 将 事件 处理 程序 指定 给 元素 时， 运行 中的 浏览器 代码 与 支持 页面 交互 的 JavaScript 代码 之间 就会 建立 一个 连接。 这种 连接 越多， 页面 执行 起来 就 越慢。</li><li>13.6　模拟事件 &gt; 位置 14682<br>是，“ DOM2 级 事件” 并没有 专门 规定 键盘 事件， 后来 的“ DOM3 级 事件” 中 才 正式 将其 作为 一种 事件 给出 规定。 IE9 是 目前 唯一 支持 DOM3 级 键盘 事件 的 浏览器。 不过， 在 其他 浏览器 中， 在 现有 方法 的 基础上， 可以 通过 几种 方式 来 模拟 键盘 事件。</li><li>13.6　模拟事件 &gt; 位置 14695<br>创建 鼠标 事件 对象 的 方法 是 为 createEvent() 传入 字符串” MouseEvents”。 返回 的 对象 有一个 名为 initMouseEvent() 方法， 用于 指定 与 该 鼠标 事件 有关 的 信息。</li><li>13.6　模拟事件 &gt; 位置 14744<br>DOM3 级 规定， 调用 createEvent() 并 传入” KeyboardEvent” 就可以 创建 一个 键盘 事件。 返回 的 事件 对象 会 包含 一个 initKeyEvent() 方法，</li><li>13.6　模拟事件 &gt; 位置 14775<br>在 Firefox 中， 调用 createEvent() 并 传入” KeyEvents” 就可以 创建 一个 键盘 事件。 返回 的 事件 对象 会 包含 一个 initKeyEvent() 方法， 这个 方法 接受 下列 10 个 参数。</li><li>13.6　模拟事件 &gt; 位置 14820<br>虽然 鼠标 事件 和 键盘 事件 是在 浏览器 中最 经常 模拟 的 事件， 但 有时候 同样 需要 模拟 变动 事件 和 HTML 事件。 要 模拟 变动 事件， 可以 使用 createEvent(“ MutationEvents”) 创建 一个 包含 initMutationEvent() 方法 的 变动 事件 对象。</li><li>13.6　模拟事件 &gt; 位置 14842<br>DOM3 级 还 定义 了“ 自定义 事件”。 自定义 事件 不 是由 DOM 原生 触发 的， 它的 目的 是 让开 发 人员 创建 自己的 事件。 要 创建 新的 自定义 事件， 可以 调用 createEvent(“ CustomEvent”)。 返回 的 对象 有一个 名为 initCustomEvent() 的 方法，</li><li>13.6　模拟事件 &gt; 位置 14869<br>调用 document. createEventObject() 方法 可以 在 IE 中 创建 event 对象。 但 与 DOM 方式 不同 的 是， 这个 方法 不接受 参数， 结果 会 返回 一个 通用 的 event 对象。 然后， 你 必须 手工 为 这个 对象 添加 所有 必要 的 信息（ 没有 方法 来 辅助 完成 这一 步骤）。 最后 一步 就是 在 目标 上 调用 fireEvent() 方法， 这个 方法 接受 两个 参数： 事件 处理 程序 的 名称 和 event 对象。</li><li>13.7　小结 &gt; 位置 14903<br>建立 在 事件 冒泡 机制 之上 的 事件 委托 技术， 可以 有效地 减少 事件 处理 程序 的 数量。</li><li>13.7　小结 &gt; 位置 14904<br>建议 在 浏览器 卸载 页面 之前 移 除 页面 中的 所有 事件 处理 程序。<h2 id="第15章-使用Canvas绘图"><a href="#第15章-使用Canvas绘图" class="headerlink" title="第15章　使用Canvas绘图"></a>第15章　使用Canvas绘图</h2></li><li>15.1　基本用法 &gt; 位置 16229<br>要在 这块 画布（ canvas） 上 绘图， 需要 取得 绘图 上下文。</li><li>15.1　基本用法 &gt; 位置 16242<br>使用 toDataURL() 方法， 可以 导出 在&lt; canvas&gt; 元素 上 绘制 的 图像。</li><li>15.3　WebGL &gt; 位置 16736<br>浏览器 中 使用 的 WebGL 就是 基于 OpenGL ES 2. 0 制定 的。</li><li>15.3　WebGL &gt; 位置 16743<br>WebGL 引入 了 一个 概念， 叫 类型 化 数组（ typed arrays）。 类型 化 数组 也是 数组， 只不过 其 元素 被 设置 为 特定 类型 的 值。</li><li>15.3　WebGL &gt; 位置 16745<br>类型 化 数组 的 核心 就是 一个 名为 ArrayBuffer 的 类型。<h2 id="第16章-HTML5脚本编程"><a href="#第16章-HTML5脚本编程" class="headerlink" title="第16章　HTML5脚本编程"></a>第16章　HTML5脚本编程</h2></li><li>16.1　跨文档消息传递 &gt; 位置 17264<br>跨 文档 消息 传送（ cross- document messaging）， 有时候 简称 为 XDM， 指的 是在 来自 不同 域 的 页面 间 传递 消息。</li><li>16.1　跨文档消息传递 &gt; 位置 17267<br>XDM 的 核心 是 postMessage() 方法。</li><li>16.2　原生拖放 &gt; 位置 17377<br>只有 简单 的 拖放 而 没有 数据 变化 是 没有 什么 用的。 为了 在 拖放 操作 时 实现 数据 交换， IE 5 引入 了 dataTransfer 对象， 它是 事件 对象 的 一个 属性， 用于 从 被 拖动 元素 向 放置 目标 传递 字符串 格式 的 数据。 因为 它是 事件 对象 的 属性， 所以 只能 在 拖放 事件 的 事件 处理 程序 中 访问 dataTransfer 对象。 在 事件 处理 程序 中， 可以 使用 这个 对象 的 属性 和 方法 来 完善 拖放 功能。 目前， HTML5 规范 草案 也 收入 了 dataTransfer 对象。</li><li>16.4　历史状态管理 &gt; 位置 17754<br>过）。 HTML5 通过 更新 history 对象 为 管理 历史 状态 提供 了 方便。<h2 id="第17章-错误处理与调试"><a href="#第17章-错误处理与调试" class="headerlink" title="第17章　错误处理与调试"></a>第17章　错误处理与调试</h2></li><li>17.2　错误处理 &gt; 位置 17944<br>如果 提供 finally 子句， 则 catch 子句 就成 了 可选 的（ catch 或 finally 有一个 即可）。 IE7 及 更早 版本 中有 一个 bug： 除非 有 catch 子句， 否则 finally 中的 代码 永远 不会 执行。</li><li>17.2　错误处理 &gt; 位置 17951<br>请 读者 务必 要 记住， 只要 代码 中 包含 finally 子句， 那么 无论 try 还是 catch 语句 块 中的 return 语句 都将 被 忽略。</li><li>17.2　错误处理 &gt; 位置 18035<br>在 遇到 throw 操作 符 时， 代码 会 立即 停止 执行。 仅 当 有 try- catch 语句 捕 获到 被 抛出 的 值 时， 代码 才会 继续 执行。</li><li>17.2　错误处理 &gt; 位置 18100<br>说到 抛出 错误 与 捕获 错误， 我们 认为 只 应该 捕获 那些 你 确切 地 知道 该 如何 处理 的 错误。 捕获 错误 的 目的在于 避免 浏览器 以 默认 方式 处理 它们； 而 抛出 错误 的 目的在于 提供 错误 发生 具体 原因 的 消息。</li><li>17.2　错误处理 &gt; 位置 18103<br>任何 没有 通过 try- catch 处理 的 错误 都会 触发 window 对象 的 error 事件。 这个 事件 是 Web 浏览器 最早 支持 的 事件 之一， IE、 Firefox 和 Chrome 为 保持 向后 兼容， 并没有 对这 个 事件 作 任何 修改（ Opera 和 Safari 不支持 error 事件）。</li><li>17.2　错误处理 &gt; 位置 18169<br>使用 全等 和 非 全等 操作 符， 可以避免 发生 因为 使用 相等 和 不相等 操作 符 引发 的 类型 转换 错误， 因此 我们 强烈 推荐 使用。<h2 id="第20章-JSON"><a href="#第20章-JSON" class="headerlink" title="第20章　JSON"></a>第20章　JSON</h2></li><li>位置 20001<br>把 JSON（ JavaScript Object Notation， JavaScript 对象 表示 法）</li><li>位置 20004<br>关于 JSON， 最重要的 是要 理解 它是 一种 数据 格式， 不是 一种 编程 语言。</li><li>20.1　语法 &gt; 位置 20015<br>最简单 的 JSON 数据 形式 就是 简单 值。 例如， 下面 这个 值 是 有效 的 JSON 数据：</li><li>20.1　语法 &gt; 位置 20019<br>JavaScript 字符串 与 JSON 字符串 的 最大 区别 在于， JSON 字符串 必须 使用 双 引号（ 单 引号 会 导致 语法 错误）。</li><li>20.1　语法 &gt; 位置 20020<br>布尔 值 和 null 也是 有效 的 JSON 形式。</li><li>20.1　语法 &gt; 位置 20025<br>这 虽然 是 开发 人员 在 JavaScript 中 创建 对象 字面 量 的 标准 方式， 但 JSON 中的 对象 要求 给 属性 加引号。</li><li>20.1　语法 &gt; 位置 20032<br>对象 的 属性 必须 加 双 引号， 这 在 JSON 中 是 必需 的。</li><li>20.1　语法 &gt; 位置 20039<br>与 JavaScript 不同， JSON 中 对象 的 属性 名 任何时候 都 必须 加 双 引号。 手工 编写 JSON 时， 忘了 给 对象 属性 名 加 双 引号 或者 把 双 引号 写成 单 引号 都是 常见 的 错误。</li><li>20.2　解析与序列化 &gt; 位置 20075<br>早期 的 JSON 解析 器 基本上 就是 使用 JavaScript 的 eval() 函数。 由于 JSON 是 JavaScript 语法 的 子集， 因此 eval() 函数 可以 解析、 解释 并 返回 JavaScript 对象 和 数组。 ECMAScript 5 对 解析 JSON 的 行为 进行 规范， 定义 了 全局 对象 JSON。</li><li>20.2　解析与序列化 &gt; 位置 20108<br>JSON. stringify() 除了 要 序列 化 的 JavaScript 对象 外， 还可以 接收 另外 两个 参数， 这 两个 参数 用于 指定 以 不同 的 方式 序列 化 JavaScript 对象。 第一个 参数 是个 过滤器， 可以 是一 个数 组， 也可以 是一 个 函数； 第二个 参数 是一 个 选项， 表示 是否 在 JSON 字符串 中 保留 缩进。</li><li>20.2　解析与序列化 &gt; 位置 20178<br>JSON. stringify() 还是 不能 满足 对 某些 对象 进行 自定义 序列 化 的 需求。 在 这些 情况下， 可以 通过 对象 上 调用 toJSON() 方法， 返回 其 自身 的 JSON 数据 格式。 原生 Date 对象 有一个 toJSON() 方法， 能够 将 JavaScript 的 Date 对象 自动 转换 成 ISO 8601 日期 字符串（ 与 在 Date 对象 上 调用 toISOString() 的 结果 完全 一样）。</li><li>20.2　解析与序列化 &gt; 位置 20209<br>JSON. parse() 方法 也可以 接收 另一个 参数， 该 参数 是一 个 函数， 将 在 每个 键值 对儿 上 调用。<h2 id="第21章-Ajax与Comet"><a href="#第21章-Ajax与Comet" class="headerlink" title="第21章　Ajax与Comet"></a>第21章　Ajax与Comet</h2></li><li>位置 20247<br>Ajax， 是对 Asynchronous JavaScript + XML 的 简写。</li><li>位置 20250<br>Ajax 技术 的 核心 是 XMLHttpRequest 对象（ 简称 XHR）， 这是 由 微软 首先 引入 的 一个 特性， 其他 浏览器 提供 商 后来 都 提供 了 相同 的 实现。</li><li>21.1　XMLHttpRequest对象 &gt; 位置 20315<br>这里 的 send() 方法 接收 一个 参数， 即要 作为 请求 主体 发送 的 数据。 如果不 需要 通过 请求 主体 发送 数据， 则 必须 传入 null， 因为 这个 参数 对 有些 浏览器 来说 是 必需 的。</li><li>21.1　XMLHttpRequest对象 &gt; 位置 20369<br>代码 利用 DOM 0 级 方法 为 XHR 对象 添加 了事 件 处理 程序， 原因 是 并非 所有 浏览器 都 支持 DOM 2 级 方法。 与其 他事 件 处理 程序 不同， 这里 没 有向 onreadystatechange 事件 处理 程序 中 传递 event 对象； 必须 通过 XHR 对象 本身 来 确定 下一步 该 怎么 做。</li><li>21.1　XMLHttpRequest对象 &gt; 位置 20430<br>对 XHR 而言， 位于 传入 open() 方法 的 URL 末尾 的 查询 字符串 必须 经过 正确 的 编码 才行。</li><li>21.1　XMLHttpRequest对象 &gt; 位置 20487<br>与 GET 请求 相比， POST 请求 消耗 的 资源 会 更多 一些。 从 性能 角度 来看， 以 发送 相同 的 数据 计， GET 请求 的 速度 最多 可达到 POST 请求 的 两倍。</li><li>21.2　XMLHttpRequest 2级 &gt; 位置 20495<br>现代 Web 应用 中频 繁 使用 的 一项 功能 就是 表单 数据 的 序列 化， XMLHttpRequest 2 级 为此 定义 了 FormData 类型。</li><li>21.4　跨源资源共享 &gt; 位置 20618<br>通过 XHR 实现 Ajax 通信 的 一个 主要 限制， 来源于 跨 域 安全 策略。</li><li>21.4　跨源资源共享 &gt; 位置 20620<br>CORS（ Cross- Origin Resource Sharing， 跨 源 资源 共享） 是 W3C 的 一个 工作 草案， 定义 了 在必 须 访问 跨 源 资源 时， 浏览器 与 服务器 应该 如何 沟通。</li><li>21.4　跨源资源共享 &gt; 位置 20621<br>CORS 背后 的 基本 思想， 就是 使用 自定义 的 HTTP 头部 让 浏览器 与 服务器 进行 沟通， 从而 决定 请求 或 响应 是 应该 成功， 还是 应该 失败。</li><li>21.4　跨源资源共享 &gt; 位置 20641<br>使 CSRF（ Cross- Site Request Forgery， 跨 站点 请求 伪造）</li><li>21.4　跨源资源共享 &gt; 位置 20642<br>XSS（ Cross- Site Scripting， 跨 站点 脚本）</li><li>21.5　其他跨域技术 &gt; 位置 20807<br>Comet 是 Alex Russell1 发明 的 一个 词儿， 指的 是一 种 更 高级的 Ajax 技术（ 经常 也有 人 称为“ 服务器 推送”）。 Ajax 是 一种 从 页 面向 服务器 请求 数据 的 技术， 而 Comet 则是 一种 服务器 向 页面 推送 数据 的 技术。</li><li>21.5　其他跨域技术 &gt; 位置 20811<br>有两 种 实现 Comet 的 方式： 长 轮 询 和 流。</li><li>21.5　其他跨域技术 &gt; 位置 20829<br>在 Firefox、 Safari、 Opera 和 Chrome 中， 通过 侦听 readystatechange 事件 及 检测 readyState 的 值 是否 为 3， 就可以 利用 XHR 对象 实现 HTTP 流。</li><li>21.5　其他跨域技术 &gt; 位置 20861<br>SSE（ Server- Sent Events， 服务器 发送 事件） 是 围绕 只读 Comet 交互 推出 的 API 或者 模式。 SSE API 用于 创建 到 服务器 的 单向 连接， 服务器 通过 这个 连接 可以 发送 任意 数量 的 数据。 服务器 响应 的 MIME 类型 必须 是 text/ event- stream， 而且 是 浏览器 中的 JavaScript API 能 解析 格式 输出。 SSE 支持 短 轮 询、 长 轮 询 和 HTTP 流， 而且 能在 断开 连接 时 自动 确定 何时 重新 连接。</li><li>21.5　其他跨域技术 &gt; 位置 20867<br>SSE 的 JavaScript API 与其 他 传递 消息 的 JavaScript API 很 相似。 要 预订 新的 事件 流， 首先 要 创建 一个 新的 EventSource 对象， 并 传 进 一个 入口 点：</li><li>21.5　其他跨域技术 &gt; 位置 20982<br>面对 某个 具体 的 用 例， 在 考虑 是 使用 SSE 还是 使用 Web Sockets 时， 可以 考虑 如下 几个 因素。 首先， 你是 否 有 自由度 建立 和 维护 Web Sockets 服务器？ 因为 Web Socket 协议 不同于 HTTP， 所以 现有 服务器 不能 用于 Web Socket 通信。 SSE 倒是 通过 常规 HTTP 通信， 因此 现有 服务器 就可以 满足 需求。</li><li>21.5　其他跨域技术 &gt; 位置 20984<br>第二个 要 考虑 的 问题是 到底 需 不需要 双向 通信。 如果 用 例 只需 读取 服务器 数据（ 如 比赛 成绩）， 那么 SSE 比较 容易 实现。 如果 用 例 必须 双向 通信（ 如 聊天 室）， 那么 Web Sockets 显然 更好。 别 忘了， 在 不能 选择 Web Sockets 的 情况下， 组合 XHR 和 SSE 也是 能 实现 双向 通信 的。</li><li>21.6　安全 &gt; 位置 20994<br>对于 未被 授权 系统 有权 访问 某个 资源 的 情况， 我们 称之为 CSRF（ Cross- Site Request Forgery， 跨 站点 请求 伪造）。</li><li>21.6　安全 &gt; 位置 20998<br>要求 以 SSL 连接 来访 问 可以 通过 XHR 请求 的 资源。 要求 每一 次 请求 都要 附带 经过 相应 算法 计算 得到 的 验证 码。</li><li>21.7　小结 &gt; 位置 21017<br>同源 策略 是对 XHR 的 一个 主要 约束， 它为 通信 设置 了“ 相同 的 域、 相同 的 端口、 相同 的 协议” 这一 限制。 试图 访问 上述 限制 之外 的 资源， 都会 引发 安全 错误， 除非 采用 被 认可 的 跨 域 解决 方案。 这个 解决 方案 叫做 CORS（ Cross- Origin Resource Sharing， 跨 源 资源 共享）， IE8 通过 XDomainRequest 对象 支持 CORS， 其他 浏览器 通过 XHR 对象 原生 支持 CORS。 图像 Ping 和 JSONP 是 另外 两种 跨 域 通信 的 技术， 但不 如 CORS 稳妥。<h2 id="第22章-高级技巧"><a href="#第22章-高级技巧" class="headerlink" title="第22章　高级技巧"></a>第22章　高级技巧</h2></li><li>22.1　高级函数 &gt; 位置 21112<br>作用域 安全 的 构造 函数。</li><li>22.1　高级函数 &gt; 位置 21193<br>在 第一次 调用 的 过程中， 该 函数 会被 覆盖 为 另外 一个 按 合适 方式 执行 的 函数， 这样 任何 对 原函数 的 调用 都不 用 再经 过 执行 的 分支 了。</li><li>22.1　高级函数 &gt; 位置 21220<br>第二 种 实现 惰性 载入 的 方式 是在 声明 函数 时 就 指定 适当 的 函数。</li><li>22.1　高级函数 &gt; 位置 21242<br>惰性 载入 函数 的 优点 是 只在 执行 分支 代码 时 牺牲 一点儿 性能。</li><li>22.1　高级函数 &gt; 位置 21307<br>与 函数 绑 定 紧密 相关 的 主题 是 函数 柯 里 化（ function currying）， 它 用于 创建 已经 设置 好了 一个 或 多个 参数 的 函数。 函数 柯 里 化 的 基本 方法 和 函数 绑 定 是 一样 的： 使用 一个 闭 包 返回 一个 函数。</li><li>22.2　防篡改对象 &gt; 位置 21399<br>使用 Object. preventExtensions() 方法 可以 改变 这个 行为， 让你 不能 再给 对象 添加 属性 和 方法。</li><li>22.2　防篡改对象 &gt; 位置 21408<br>使用 Object. istExtensible() 方法 还可以 确定 对象 是否 可以 扩展。</li><li>22.2　防篡改对象 &gt; 位置 21417<br>要 密封 对象， 可以 使用 Object. seal() 方法。</li><li>22.2　防篡改对象 &gt; 位置 21425<br>使用 Object. isSealed() 方法 可以 确定 对象 是否 被 密封 了。</li><li>22.2　防篡改对象 &gt; 位置 21426<br>因为 被 密封 的 对象 不可 扩展， 所以 用 Object. isExtensible() 检测 密封 的 对象 也会 返回 false。</li><li>22.2　防篡改对象 &gt; 位置 21431<br>最 严格 的 防 篡改 级别 是 冻结 对象（ frozen object）。</li><li>22.2　防篡改对象 &gt; 位置 21435<br>ECMAScript 5 定义 的 Object. freeze() 方法 可以 用来 冻结 对象。</li><li>22.2　防篡改对象 &gt; 位置 21440<br>当然， 也有 一个 Object. isFrozen() 方法 用于 检测 冻结 对象。</li><li>22.3　高级定时器 &gt; 位置 21468<br>定时器 对 队列 的 工作 方式 是， 当 特定 时间 过去 后 将 代码 插入。 注意， 给 队列 添加 代码 并不 意味着 对 它 立刻 执行， 而 只能 表示 它 会 尽快 执行。</li><li>22.3　高级定时器 &gt; 位置 21479<br>关于 定时器 要 记住 的 最重要的 事情 是， 指定 的 时间 间隔 表示 何时 将 定时器 的 代码 添加 到 队列， 而 不是 何时 实际 执行 代码。</li><li>22.3　高级定时器 &gt; 位置 21509<br>为了 避免 setInterval() 的 重复 定时器 的 这 2 个 缺点， 你 可以 用 如下 模式 使用 链式 setTimeout() 调用。</li><li>22.3　高级定时器 &gt; 位置 21531<br>其中 一个 限制 是 长时间 运行 脚本 的 制约， 如果 代码 运行 超过 特定 的 时间 或者 特定 语句 数量 就 不让 它 继续 执行。</li><li>22.3　高级定时器 &gt; 位置 21532<br>如果 代码 达到 了 这个 限制， 会 弹出 一个 浏览器 错误 的 对话框， 告诉 用户 某个 脚本 会用 过长 的 时间 执行， 询问 是 允许 其 继续 执行 还是 停止 它。 所有 JavaScript 开发 人员 的 目标 就是， 确保 用户 永远 不 会在 浏览器 中看 到这 个 令人费解 的 对话框。 定时器 是 绕开 此 限制 的 方法 之一。</li><li>22.3　高级定时器 &gt; 位置 21546<br>当你 发现 某个 循环 占用 了 大量 时间， 同时 对于 上述 两个 问题， 你的 回答 都是“ 否”， 那么 你就 可以 使用 定时器 分割 这个 循环。 这是 一种 叫做 数组 分块（ array chunking） 的 技术， 小块 小块 地处 理 数组， 通常 每次 一 小块。</li><li>22.3　高级定时器 &gt; 位置 21586<br>一旦 某个 函数 需要 花 50ms 以上 的 时间 完成， 那么 最好 看看 能否 将 任务 分割 为 一系列 可以 使用 定时器 的 小 任务。</li><li>22.4　自定义事件 &gt; 位置 21653<br>事件 是 JavaScript 与 浏览器 交互 的 主要 途径。</li><li>22.4　自定义事件 &gt; 位置 21659<br>事件 是与 DOM 交互 的 最 常见 的 方式， 但它 们 也可以 用于 非 DOM 代码 中—— 通过 实现 自定义 事件。<h2 id="第23章-离线应用与客户端存储"><a href="#第23章-离线应用与客户端存储" class="headerlink" title="第23章　离线应用与客户端存储"></a>第23章　离线应用与客户端存储</h2></li><li>23.1　离线检测 &gt; 位置 21942<br>线， HTML5 为此 定义 了 一个 navigator. onLine 属性， 这个 属性 值 为 true 表示 设备 能 上网， 值 为 false 表示 设备 离 线。</li><li>23.2　应用缓存 &gt; 位置 21973<br>HTML5 的 应用 缓存（ application cache）， 或者 简称 为 appcache， 是 专门 为 开发 离 线 Web 应用 而 设计 的。</li><li>23.2　应用缓存 &gt; 位置 21989<br>虽然 应用 缓存 的 意图 是 确保 离 线 时 资源 可用， 但也 有 相应 的 JavaScript API 让你 知道 它 都在 做 什么。 这个 API 的 核心 是 applicationCache 对象，</li><li>23.3　数据存储 &gt; 位置 22051</li></ul><ol start="2"><li>cookie 的 构成</li></ol><ul><li>23.3　数据存储 &gt; 位置 22084<br>因为 设置 了 secure 标志， 这个 cookie 只能 通过 SSL 连接 才能 传输。</li><li>23.3　数据存储 &gt; 位置 22290<br>在 IE5. 0 中， 微软 通过 一个 自定义 行为 引入 了 持久 化 用户 数据 的 概念。 用户 数据 允许 每个 文档 最多 128KB 数据， 每个 域名 最多 1MB 数据。 要使 用 持久 化 用户 数据， 首先 必须 如下 所示， 使用 CSS 在某 个 元素 上 指定 userData 行为：<h2 id="第24章-最佳实践"><a href="#第24章-最佳实践" class="headerlink" title="第24章　最佳实践"></a>第24章　最佳实践</h2></li><li>24.1　可维护性 &gt; 位置 23140<br>所以， 最佳 的 方法 便是 永远 不修 改 不 是由 你 所有 的 对象。</li><li>24.2　性能 &gt; 位置 23249<br>访问 全局 变量 总是 要比 访问 局部 变量 慢， 因为 需要 遍历 作用域 链。 只要 能 减少 花费 在 作用域 链 上 的 时间， 就能 增加 脚本 的 整体 性能。</li><li>24.2　性能 &gt; 位置 23250<br>避免 全局 查找</li><li>24.2　性能 &gt; 位置 23269<br>避免 with 语句</li><li>24.2　性能 &gt; 位置 23274<br>必须 使用 with 语句 的 情况 很少， 因为 它 主要 用于 消除 额外 的 字符。</li><li>24.2　性能 &gt; 位置 23287<br>　 选择 正确 方法</li><li>24.2　性能 &gt; 位置 23290<br>在 计算机 科学 中， 算法 的 复杂度 是 使用 O 符号 来 表示 的。 最简单、 最 快捷 的 算法 是 常 数值 即 O( 1)。</li><li>24.2　性能 &gt; 位置 23335<br>减值 迭代—— 大多数 循环 使用 一个 从 0 开始、 增加 到 某个 特定 值 的 迭代 器。 在 很多 情况下， 从 最大值 开始， 在 循环 中 不断 减值 的 迭代 器 更加 高效。</li><li>24.2　性能 &gt; 位置 23337<br>简化 终止 条件—— 由于 每次 循环 过程 都会 计算 终止 条件， 所以 必须 保证 它 尽可能 快。 也就是说 避免 属性 查找 或 其他 O( n) 的 操作。</li><li>24.2　性能 &gt; 位置 23338<br>简化 循环 体—— 循环 体 是 执行 最多 的， 所以 要 确保 其 被 最大限度 地 优化。 确保 没有 某些 可以 被 很容易 移出 循环 的 密集 计算。</li><li>24.2　性能 &gt; 位置 23340<br>使用 后 测试 循环—— 最 常用 for 循环 和 while 循环 都是 前 测试 循环。 而 如 do- while 这种 后 测试 循环， 可以避免 最初 终止 条件 的 计算， 因此 运行 更快。</li><li>24.2　性能 &gt; 位置 23367<br>如果 循环 中的 迭代 次数 不能 事先 确定， 那 可以 考虑 使用 一种 叫做 Duff 装置 的 技术。</li><li>24.2　性能 &gt; 位置 23400<br>当 JavaScript 代码 想 解析 JavaScript 的 时候 就会 存在 双重 解释 惩罚。 当 使用 eval() 函数 或者是 Function 构造 函数 以及 使用 setTimeout() 传 一个 字符串 参数 时 都会 发生 这种 情况。</li><li>24.3　部署 &gt; 位置 23633<br>当 谈及 JavaScript 文件 压缩， 其实 在 讨论 两个 东西： 代码 长度 和 配 重（ Wire weight）。</li><li>24.3　部署 &gt; 位置 23718<br>mod_ gzip 和 mod_ deflate 都可以 节省 大约 70% 的 JavaScript 文件 大小。 这 很大 程度 上 是因为 JavaScript 都是 文本 文件， 因此 可以 非常 有效地 进行 压缩。<h2 id="第25章-新兴的API"><a href="#第25章-新兴的API" class="headerlink" title="第25章　新兴的API"></a>第25章　新兴的API</h2></li><li>25.1　requestAnimationFrame() &gt; 位置 23750<br>Firefox 4 最早 为 JavaScript 动画 添加 了 一个 新 API， 即 mozRequestAnimationFrame()。 这个 方法 会 告诉 浏览器： 有一个 动画 开始 了。 进而 浏览器 就可以 确定 重 绘 的 最佳 方式。</li><li>25.4　File API &gt; 位置 24003<br>FileReader 类型 实现 的 是一 种 异步 文件 读取 机制。 可以 把 FileReader 想象 成 XMLHttpRequest， 区别 只是 它 读 取的 是 文件 系统， 而 不是 远程 服务器。 为了 读取 文件 中的 数据， FileReader 提供 了 如下 几个 方法。</li><li>25.4　File API &gt; 位置 24103<br>对象 URL 也 被称为 blob URL， 指的 是 引用 保存 在 File 或 Blob 中 数据 的 URL。 使用 对象 URL 的 好处 是 可以 不必 把 文件 内容 读取 到 JavaScript 中 而 直接 使用 文件 内容。</li><li>25.4　File API &gt; 位置 24128<br>要 手工 释放 内存， 可以 把 对象 URL 传给 window. URL. revokeOjbectURL()（ 在 Chrome 中 是 window. webkitURL. revokeObjectURL()）。</li><li>25.4　File API &gt; 位置 24136<br>支持 对象 URL 的 浏览器 有 IE10+、 Firefox 4 和 Chrome。</li><li>25.4　File API &gt; 位置 24138<br>类似， 从 桌 面上 把 文件 拖放 到 浏览器 中 也会 触发 drop 事件。 而且 可以 在 event. dataTransfer. files 中 读取 到 被 放置 的 文件， 当然 此时 它是 一个 File 对象， 与 通过 文件 输入 字段 取得 的 File 对象 一样。</li><li>25.7　小结 &gt; 位置 24361<br>requestAnimationFrame()： 是 一个 着眼于 优化 JavaScript 动画 的 API， 能够 在 动画 运行 期间 发出 信号。 通过 这种 机制， 浏览器 就能 够 自动 优化 屏幕 重 绘 操作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《JavaScript高级程序设计(第3版) (图灵程序设计丛书)》&lt;br&gt;作者：泽卡斯(Zakas. Nicholas C.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第1章-BOM&quot;&gt;&lt;a href=&quot;#第1章-BOM&quot; class
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://github.com/leafsu3340.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="https://github.com/leafsu3340.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/leafsu3340.github.io/2019/09/18/hello-world/"/>
    <id>https://github.com/leafsu3340.github.io/2019/09/18/hello-world/</id>
    <published>2019-09-18T02:14:39.643Z</published>
    <updated>2020-02-05T06:15:16.463Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="about" scheme="https://github.com/leafsu3340.github.io/categories/about/"/>
    
    
      <category term="hexo" scheme="https://github.com/leafsu3340.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
